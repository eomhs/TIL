# 응용 계층
## DNS와 자원
### 메시지를 주고받기 위해
- 메시지를 주고받는 송수신지 파악
    - IP 주소, 도메인 네임
- 송수신하고자 하는 정보 파악
    - Resource
### 도메인 네임과 네임 서버
- IP 주소만으로 송수신지 특정하는 것은 번거로움
    - 통신하고자 하는 모든 호스트의 IP 주소를 기억하기 어려움
    - IP 주소는 언제든 바뀔 수도 있음
    - 그래서 상대 호스트 특정을 위해 도메인 네임 사용
    - 도메인 네임
        - 호스트의 IP 주소와 대응되는 문자열 형태의 호스트 특정 정보
    - 네임 서버(DNS 서버)에서 관리
        - IP 주소 변경되어도 도메인 네임 다시 대응하면 그만임
    - 네임 서버가 공용 전화번호부라면, 개인 전화번호부 같은 hosts 파일도 있음
        - 도메인 네임과 IP 주소의 대응 관계를 담은 파일
        - hosts 파일 위치: `/etc/hosts`
### 네임 서버의 관리
- 도메인 네임의 구조로 알아보는 네임 서버 관리 방법
- 점(.)을 기준으로 계층적으로 분류
    - 루트 도메인(root domain): 맨 끝에 사실 .이 있는데 생략된 것
    - 최상위 도메인(TLD)
    - 2단계 도메인, 3단계 도메인, 4단계 도메인...
- 전체 주소 도메인 네임(FQDN: Fully-Qualified Domain Name)
    - 전체 도메인 계층을 모두 포함하는 도메인 네임
    - FQDN까지 알면 비로소 하나의 호스트를 식별할 수 있게 됨
- 서브 도메인(subdomain)
    - 다른 도메인이 포함된 도메인
    - ex) google.com의 서브 도메인
        - www.google.com
        - mail.google.com
        - drive.google.com 등등
- 계층적 도메인 네임
    - 이를 관리하기 위한 네임 서버도 계층적으로 관리
    - 네임 서버는 전 세계 여러 군데 분산되어 위치
- 계층적이고 분산된 도메인 네임에 대한 관리 체계 = DNS
### 계층적 네임 서버
- 도메인 네임에 대응하는 IP 주소를 알아내는 과정
    - 도메인 네임을 풀이(resolve)한다
    - 계층적이고 분산된 네임 서버들이 사용됨
    - 주요 네임 서버의 유형: 로컬 네임 서버(리졸버), 루트 네임 서버, TLD 네임 서버, 책임 네임 서버
- 로컬 네임 서버(local name server)
    - 클라이언트와 맞닿아 있는 네임 서버
        - 클라이언트가 도메인 네임을 통해 IP 주소를 알아내고자 할 때 가장 먼저 찾게 되는 네임 서버
        - 로컬 네임 서버의 주손느 일반적으로 ISP에서 할당
        - 공개 DNS 서버(public DNS Server)를 이용할 수도 있음
- 루트 네임 서버(root name server)
    - 루트 도메인을 관장하는 네임 서버
        - 로컬 네임 서버가 대응되는 IP 주소를 모를 경우
        - TLD 네임 서버의 IP 주소를 반환할 수 있음
- TLD 네임 서버
    - TLD를 관리하는 네임 서버
    - DNS 질의에 대해 TLD의 하위 도메인 네임을 관리하는 네임 서버 주소 반환
        - 하위 도메인 네임을 관리하는 네임 서버는 그보다 하위 도메인 네임을 관리하는 네임 서버 주소를 반환
- 책임 네임 서버(authoritative name server)
    - 특정 도메인 영역(zone)을 관리하는 네임 서버
        - 다른 네임 서버에게 떠넘기지 않고 곧바로 답할 수 있는 네임 서버
        - 즉, 책임 네임 서버는 로컬 네임 서버가 마지막으로 질의하는 네임 서버
        - 일반적으로 로컬 네임 서버는 책임 네임 서버로부터 원하는 IP 주소를 알아냄
- 네임 서버의 계층적 구조를 토대로 IP 주소를 알아내는 과정
    - 재귀적 질의(recursive query)
    - 반복적 질의(iterative query)
- 재귀적 질의
    - 클라이언트 -> 로컬 네임 서버 -> 루트 네임 서버 -> TLD 네임 서버 -> 책임 네임 서버에게 질의
    - 최종 응답 결과를 역순으로 전달
- 반복적 질의
    - 네임 서버에 일일이 질의-응답 반복
    - 최종 응답 결과를 클라이언트에게 전달
### DNS 캐시
- 조금 문제가 있다
    - 앞선 예시는 8단계를 거치게 됨
    - 시간이 오래 걸리고 네트워크상의 메시지 수가 지나치게 늘어날 수 있음
    - 루트 네임 서버에 과부하 우려
- DNS 캐시(DNS cache)
    - 네임 서버들이 기존에 응답받은 결과를 임시로 저장했다가 추후 같은 질의에 이를 활용
    - DNS 캐시를 저장하는 용도로만 사용되는 서버도 있음
    - DNS 캐시를 활용하면 더 짧은 시간 안에 원하는 IP 주소를 얻어낼 수 있음
    - DNS 캐시는 영원히 남아있는 것은 아님(TTL)
 ### 자원을 식별하는 URI 
- 자원(resource): 네트워크상의 메시지를 통해 주고받는 대상
    - 두 호스트가 네트워크를 통해 서로 정보를 주고받을 때, 송수신하는 대상
        - HTML 파일
        - 이미지나 동영상 파일
        - 텍스트 파일 등
- 자원은 'HTTP 요청 메시지의 대상'이라 보기도
- 자원을 식별할 수 있는 정보, URI (Uniform Resource Identifier)
    - URL (Uniform Resource Locator)
        - 위치를 지용해 자원을 식별
        - 거의 이 방식
    - URN (Uniform Resource Name)
        - 이름을 이용해 자원을 식별
### URL
- 오늘날 인터넷 환경에서 자원 식별에 더 많이 사용되는 식별자
- URL의 구조 (RFC 3986)
    1. scheme
        - URL의 첫 부분인 scheme은 '자원에 접근하는 방법'을 의미
        - 일반적으로 사용할 프로토콜이 명시
            - ex) HTTP/HTTPS 등
    2. authority
        - authority에는 '호스트를 특정할 수 있는 정보', 이를테면 IP 주소 혹은 도메인 네임이 명시
        - 콜론(:) 뒤에 포트 번호를 덧붙일 수도 있음
    3. path
        - path에는 '자원이 위치한 경로'가 명시
        - 자원의 위치는 슬래시(/)를 기준으로 계층적으로 표현되고, 최상위 경로 또한 슬래시로 표현
    4. query
        - query string, query parameter
        - 물음표(?)로 시작되는 <key, value> 형태의 데이터
        - 앰퍼샌드(&)로 여러 쿼리 문자열을 덧붙일 수 있음
    5. fragment
        - fragment는 '자원의 한 조각을 가리키기 위한 정보'
            - HTML 파일과 같은 자원에서 특정 부분을 가리키기 위해 사용
            - 샵(#) 사용
### URN
- URL의 단점
    - 위치를 기반으로 식별하는데 자원의 위치는 언제든 변할 수 있음
- URN의 장점
    - 자원에 고유한 이름을 붙이는 이름 기반 식별자라 자원의 위치와 무관하게 자원을 식별
- URN은 아직 URL만큼 널리 채택된 방식은 아님
### 네임 서버는 무엇을 저장할까
- DNS 자원 레코드(DNS resource record)
    - 이름(호스트 이름, Record Name)
    - 값(Value)
    - TTL
    - 레코드 유형(Record Type)
        - 레코드 유형이 달라지면 레코드 이름과 값의 의미가 달라짐
- DNS 레코드 예제
    - 타입: A, 이름: example.com, 값: 1.2.3.4, TTL: 300
    - 타입: CNAMe, 이름: www.example.com, 값: example.com, TTL: 300

## HTTP
### HTTP의 네 가지 특성
- HTTP는
    - 요청-응답 기반 프로토콜
    - 미디어 독립적 프로토콜
    - 상태를 유지하지 않는 프로토콜
    - 지속 연결을 지원하는 프로토콜
- 요청-응답 기반 프로토콜
    - HTTP는 클라이언트 서버 구조 기반의 요청-응답 프로토콜
        - HTTP의 요청 메시지와 HTTP 응답 메시지는 메시지 형태가 다름
- 미디어 독립적 프로토콜
    - HTTP를 정의한 공식 문서(RFC 9110)
        - HTTP가 요청하는 대상은 자원이다. HTTP는 자원의 특성을 제한하지 않으며, 자원과 상호작용하는 데 사용할 수 있는 인터페이스를 정의할 뿐이다
    - 즉, HTTP는 주고받을 자원의 특성과 무관하게 인터페이스 역할만 함
    - 미디어 타입(Media Type): HTTP에서 메시지로 주고받는 자원의 종류, 확장자
        - MIME 타입(Multipurpose Internet Mail Extensions Type)이라고도 함
- 미디어 독립적 프로토콜:미디어 타입의 구성과 종류
    - 슬래시를 기준으로 '타입/서브타입(type/subtype)' 형식으로 구성
        - 타입: 데이터의 유형
        - 서브타입: 주어진 타입에 대한 세부 유형
    - 미디어 타입에는 부가적인 설명을 위해 선택적으로 매개변수 포함 가능
        - type/subtype; parameter=value
            ex) text/html; charset=UTF-8
    - 여러 미디어 타입 통칭: 별표 문자(*)
- 상태를 유지하지 않는 프로토콜
    - HTTP는 상태를 유지하지 않는 스테이트리스(stateless) 프로토콜
        - 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는다는 의미
        - 클라이언트의 모든 HTTP 요청은 기본적으로 독립적인 요청으로 간주
    - 왜 HTTP는 상태를 유지하지 않을까?
        - HTTP 서버는 일반적으로 많은 클라이언트와 동시에 상호 작용
        - 모든 클라이언트의 상태 정보를 유지하는 것은 서버에 큰 부담
    - 특정 클라이언트가 특정 서버에 종속되는 상황 방지
        - HTTP가 상태를 유지하는 프로토콜이라면 클라이언트는 자신의 상태를 기억하는 특정 서버하고만 통신
    - 확장성, 견고성
- 지속 연결 프로토콜
    - 비지속 연결
        - 초기의 HTTP 버전(HTTP 1.0 이하)
        - TCP 연결 수립한 후, 요청에 대한 응답을 받으면 연결 종료
        - 추가적인 요청-응답을 하기 위해서는 다시 TCP 연결 수립부터 반복
    - 지속 연결(persistent connection) 또는 킵 얼라이브(keep-alive)
        - 최근 대중적으로 사용되는 HTTP 버전(HTTP 1.1 이상)
        - 하나의 TCP 연결상에서 여러 개의 요청-응답을 주고받을 수 있는 기술
### HTTP 메시지 구조(HTTP 1.1 기준)
- HTTP 메시지 구조
    - 시작 라인, 필드 라인, 메시지 본문으로 구성
        - 필드 라인은 없거나 여러 개 있을 수 있음
        - 메시지 본문은 없을 수 있음
        - 필드 라인과 메시지 본문 사이에는 빈 줄바꿈이 있음
- HTTP 메시지 구조: 시작 라인(start-line) - 요청 라인
    - 메서드(method)
        - 클라이언트가 서버의 자원에 대해 수행할 작업의 종류
        - 대표적으로 GET, POST, PUT, DELETE 등
    - 요청 대상(request-target)
        - HTTP 요청을 보낼 서버의 자원
        - 보통 (쿼리가 포함된) URI의 경로가 명시
        - 만약 하위 경로가 없더라도 요청 대상은 슬래시로 표기
    - HTTP 버전(HTTP-version)
        - 사용된 HTTP 버전
        - 'HTTP/<버전>'이라는 표기 방식을 따름
- HTTP 메시지 구조: 시작 라인(start-line) - 상태 라인
    - 상태 코드(status code), 이유 구문(reason phrase)
        - 상태 코드: 요청에 대한 결과를 나타내는 세 자리 정수
        - 이유 구문: 상태 코드에 대한 문자열 형태의 설명
- HTTP 메시지 구조: 필드 라인 또는 헤더 라인
    - 0개 이상의 HTTP 헤더 명시
    - HTTP 헤더: HTTP 통신에 필요한 부가 정보
    - 콜론(:)을 기준으로 헤더 이름과 하나 이상의 헤더값으로 구성
- 메시지 본문(message-body)
    - HTTP 요청 혹은 응답 메시지에서 본문이 필요할 경우 선택적으로 메시지 본문에 명시
    - 다양한 콘텐츠 타입이 사용 가능

### HTTP 메서드
- HTTP 메서드 정리
    - GET, HEAD, POST, PUT, PATCH, DELETE
- GET
    - 특정 자원을 조회할 때 사용되는 메서드
        - 클라이언트가 서버에게 '자원을 가져다주세요'라 요청 보내는 것과 같음
    1. 요청 메시지
        ```
        GET / example-page HTTP/1.1
        Host: www.example.com
        Accept: *
        ```
    2. 응답 메시지
        ```
        HTTP/1.1 200 OK
        Content-Type: text/html
        Content-Length: 1234

        대충 html content
        ```
- HEAD
    - HEAD 메서드를 사용하면 서버는 요청에 대한 응답으로 응답 메시지의 헤더만을 반환
- POST
    - 서버로 하여금 특정 작업을 처리하도록 요청하는 메서드
    - 처리할 대상은 흔히 메시지 본문으로 명시
    - 많은 경우 클라이언트가 서버에 새로운 자원을 생성하고자 할 때 사용
        - 새로운 자원이 생성
        시 서버는 응답 메시지의 Location 헤더를 통해 새로 생성된 자원의 위치를 알려줌
- PUT
    - 요청 자원이 없다면 메시지 본문으로 자원을 새롭게 생성
    - 요청 자원이 존재한다면 메시지 본문으로 자원을 완전히 대체
- PATCH
    - 부분적 수정
- DELETE
    - 특정 자원을 삭제하고 싶을 때 사용
### HTTP 상태 코드
- 상태 코드는 요청에 대한 결과를 나타내는 세 자리 정수
    - 상태 코드는 백의 자리 수를 기준으로 유형을 구분
        - 100번대: 정보성 상태 코드
        - 200번대: 성공 상태 코드
        - 300번대: 리다이렉션 상태 코드
        - 400번대: 클라이언트 에러 상태 코드
        - 500번대: 서버 에러 상태 코드
### HTTP/1.0
- HEAD, POST 등 GET 이외에 메서드 도입
- 헤더 지원 시작
- 공식적으로는 지속 연결 미지원
### HTTP/1.1
- 오늘날까지 널리 사용되는 버전
    - 지속 연결 공식적 지원
    - 파이프라이닝, 콘텐츠 협상 기능 등 다양한 편의 기능 추가
    - 메시지 본문은 평문
    - HTTP 1.1의 고질적 문제, HOL 블로킹(Head-of-line blocking)
        - 같은 큐에 대기하며 순차적으로 처리되는 여러 패킷이 있을 경우
        - 첫 번째 패킷의 처리 지연으로 인해 나머지 패킷 처리도 모두 지연되는 문제 상황
### HTTP/2.0
- 오늘날까지 널리 사용되는 버전
    - HTTP/1.1의 효율과 성능을 높이기 위한 버전
    - 메시지 본문은 바이너리 데이터
    - 헤더 압축 전송 기능
    - 서버 푸시(server push) 기능
        - 클라이언트가 요청하지 않았더라도 미래에 필요할 것으로 예상되는 자원을 미리 전송하는 기능
    - HTTP 멀티플렉싱(multiplexing)을 통한 HOL 블로킹 완화
        - 여러 스트림(stream)을 활용해 병렬적으로 메시지를 주고받는 기술
        - 요청-응답 단위는 하나의 스트림에서 이루어짐
        - 스트림별 독립적인 송수신 가능
        - 별도의 스트림을 통해 여러 데이터를 병렬적으로 주고받으며 HOL 블로킹 완화
### HTTP/3.0
- 오늘날 점차 사용 확대되는 버전
    - 이전까지의 HTTP 버전: TCP 기반 동작
    - HTTP/3.0: UDP 기반 프로토콜인 QUIC(Quick UDP Internet Connections) 기만으로 동작
    - UDP가 비연결형 프로토콜이라 빠른 송수신 가능
        