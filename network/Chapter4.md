# 전송 계층
## 전송 계층 개요: IP의 한계와 포트
### 전송 계층 개요
- 네트워크 계층과 응용 계층 사이의 전송 계층
    - IP 한계 보완: 신뢰할 수 있는 통신과 연결형 통신 기능 제공
    - 응용 계층의 프로세스 식별: 응용 포트 번호 활용
- 신뢰할 수 없는 통신과 비연결형 통신
    - IP의 특징
        - 신뢰할 수 없는 (비신뢰성) 프로토콜(unreliable protocol)
            - 패킷이 수신지까지 제대로 전송되었다는 보장을 하지 않음
        - 비연결형 프로토콜(connectionless protocol)
            - 송수신 호스트 간에 사전 연결 수립 작업을 거치지 않음
    - IP 패킷의 전달: 신뢰성이 없는 통신 + 비연결형 통신
- IP는 왜 신뢰할 수 없는, 비연결형 통신을 할까?
    - 주된 이유는 성능
    - 신뢰성 있는 통신이 모든 경우에 필요한 것은 아님

### IP 한계를 보완하는 전송 계층
- TCP
    - 연결형 통신을 가능하게 함
        - 송수신하는 동안에는 연결을 유지하고, 송수신이 끝나면 연결을 종료
    - 신뢰성 있는 통신을 가능하게 함
        - 재전송을 통한 오류 제어, 흐름 제어, 혼잡 제어 등 다양한 기능들을 제공
- UDP
    - 신뢰할 수 없는 통신, 비연결형 통신을 가능하게 함
    - TCP보다는 비교적 빠른 전송이 가능

### 응용 계층을 식별하는 전송 계층
- 포트를 활용한 애플리케이션 식별
    - 포트(port): 네트워크 상의 애플리케이션 식별 정보
- 포트의 분류
    - 패킷 내 수신지 포트와 송신지 포트를 통해 송수신지 호스트의 애플리케이션을 식별
    - 16비트로 표현 가능: 사용 가능한 포트의 수는 $2^{16}$개
        - 할당 가능한 포트 번호: 0 ~ 65535
- 포트의 분류
    - 잘 알려진 포트(well-known port)
        - 0 ~ 1023
        - 시스템 포트(system port)
        - 범용적으로 사용되는 애플리케이션 프로토콜이 일반적으로 사용하는 포트 번호 (SSH, HTTP, HTTPS 등)
    - 등록된 포트(registered port)
        - 1024 ~ 49151
        - 잘 알려진 포트에 비해서는 덜 범용적
        - 흔히 사용되는 애플리케이션 프로토콜에 할당하기 위해 사용
        - 인터넷 할당 번호 관리 기관(IANA)에서 well-known과 registered port에 대한 정보를 볼 수 있음
    - 동적 포트(dynamic port)
        - 특별히 관리되지 않는 포트 번호 범위: 자유롭게 사용 가능
        - **서버**는 대부분 well-known과 registerd port 사용
        - **클라이언트**는 대부분 dynamic port 사용
            - 예) 웹 브라우저
- '특정 호스트'에서 실행 중인 '특정 애플리케이션 프로세스' 식별
    - IP주소:포트 번호 형식
- 포트 번호 관찰하고 해석하기
    - 리소스 모니터의 네트워크 탭 -> TCP 연결에서 확인 가능
### 포트를 활용하는 기술: 포트 기반 NAT
- NAT
    - NAT 변환 테이블: 변환의 대상이 되는 IP 주소 쌍
    - 사설 IP 주소 하나당 공인 IP 주소 하나가 대응: 많은 사설 IP 주소를 변환하기에는 무리가 있음
    - 공인 IP 주소의 낭비: 사설 IP 주소의 수만큼 공인 IP 주소가 필요
- 포트 기반의 NAT, NAPT
    - NAPT(Network Address Port Translation) 또는 APT
    - NAPT는 NAT 테이블에 변환할 IP 주소 쌍과 더불이 포트 번호도 함께 기록하고, 변환
    - 하나의 공인 IP 주소(1)을 여러 사설 IP 주소(N)가 공유 가능
        - 사설 IP 주소: 공인 IP 주소를 N:1로 변환
        - 공인 IP 주소 수 부족 문제를 개선한 기술  

<img src = "https://github.com/eomhs/TIL/blob/main/figures/IP%20Class.png" width="800" height="500"/> 

### 포트 포워딩
- 포트 포워딩
    - 네트워크 내 특정 호스트에 IP 주소와 포트 번호를 미리 할당하고
    - 해당 IP 주소:포트 번호로써 해당 호스트에게 패킷을 전달하는 기능
    - 특정 IP 주소와 포트 번호 쌍을 호스트에게 할당한 뒤
    - 외부 호스트에게 해당 접속 정보(IP 주소:포트 번호)를 알려 주면 됨

### IP의 신뢰할 수 없는 비연결형 통신
- IP의 전송 특성을 보완하는 ICMP
    - IP 패킷 전송 과정에 대한 피드백 메시지 제공
    - 피드백 메시지?
        1. 전송 과정에서 발생한 문제 상황에 대한 오류 보고
        2. 네트워크에 대한 진단 정보
- ICMP 메시지 = 타입(type) + 코드(code)
    - 타입: ICMP 메시지 유형 번호
    - 코드: 구체적인 메시지 내용 번호
- ICMP는 IP의 보조일 뿐: 신뢰성을 완전 보장하지는 않음

## TCP와 UDP
### 전송 계층의 가장 중요한 프로토콜, TCP와 UDP
- TCP(Transmission Control Protocol)
    - 신뢰할 수 있는 통신을 위한 연결형 프로토콜
- UDP(User Datagram Protocol)
    - TCP보다 신뢰성은 떨어지지만 비교적 빠른 통신이 가능한 비연결형 프로토콜
### TCP 통신 단계
- TCP 통신 단계
    - TCP는 통신(데이터 송수신)하기 전에 연결을 수립하고 통신이 끝나면 연결을 종료
- MSS(Maximum Segment Size)단위
    - MSS: TCP로 전송할 수 있는 최대 페이로드 크기
    - TCP 헤더 크기는 제외 (MTU는 포함)
### TCP 세그먼트 구조
<img src = "https://github.com/eomhs/TIL/blob/main/figures/TCP_Segment.png" width="800" height="500"/>   

- 송신지 포트, 수신지 포트
    - 송수신하는 포트 번호
- 순서 번호(sequence number)
    - 순서 번호가 명시되는 필드
    - 순서 번호
        - 송수신되는 세그먼트 데이터의 첫 바이트에 부여되는 번호
        - 세그먼트의 올바른 송수신 순서를 보장하기 위한 번호
        - 초기 순서 번호 + 송신한 바이트 수
        - 초기 순서 번호는 무작위 값
- 확인 응답 번호(acknowledgement number)
    - 상대 호스트가 보낸 세그먼트에 대한 응답
    - 다음으로 수신하기를 기대하는 순서 번호가 명시
    - 일반적으로 수신한 순서 번호 + 1
    - 확인 응답 번호 값을 보내기 위해서는 제어 비트에서 승인을 나타내는 비트인 ACK 플래그를 1로 설정
- 제어 비트(control bits) 또는 플래그 비트(flag bits)
    - 현재 세그먼트에 대한 부가 정보
    - 기본적으로 8비트로 구성
        - ACK: 세그먼트의 승인을 나타내기 위한 비트
        - SYN: 연결을 수립하기 위한 비트
        - FIN: 연결을 종료하기 위한 비트
- 윈도우(window)
    - 수신 윈도우(한 번에 수신하고자 하는 데이터의 양)의 크기가 명시
### TCP 연결 수립과 종료
- 연결 수립: 쓰리 웨이 핸드셰이크
    - 쓰리 웨이 핸드셰이크(three-way handshake): 세 개의 단계로 이루어진 TCP의 연결 수립 과정
        - SYN, SYN+ACK, ACK
    - 액티브 오픈(active open): 연결 시작 호스트의 연결 수립 과정
    - 패시브 오픈(passive open): 연결 수락 호스트의 연결 수립 과정
- 연결 종료
    - 송수신 호스트가 각자 한 번씩 FIN과 ACK를 주고받으며 TCP가 연결 종료
        - 액티브 클로즈(active close): 종료 시작 호스트의 종료 과정
        - 패시브 클로즈(passive close): 종료 수락 호스트의 종료 과정
### TCP 상태
- 상태(state): 현재 어떤 통신 과정에 있는지를 나타내는 정보
- 상태를 유지하고 활용하는 TCP
    - stateful 프로토콜
- TCP 상태의 유형
    - 연결이 수립되지 않은 상태
        - CLOSED: 아무런 연결이 없는 상태 
        - LISTEN: 일종의 연결 대기 상태(SYN 세그먼트를 기다리는 상태)
            - 서버는 주로 LISTEN 상태 유지
    - 연결 수립 과정에서 주로 볼 수 있는 상태
        - SYN-SENT: 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤 그에 대한 ACK 세그먼트를 기다리는 상태
        - SYN-RECEIVED: 패시브 오픈 호스트가 SYN+ACK 세그먼트를 보낸 뒤 그에 대한 ACK 세그먼트를 기다리는 상태
        - ESTABLISHED: 연결이 확립되었음을 나타내는 상태
    - 연결 종료 과정에서 주로 볼 수 있는 상태
        - FIN-WAIT-1: 액티브 클로즈 호스트가 FIN 세그먼트를 보낸 뒤 대기하는 상태
        - CLOSE-WAIT: FIN 세그먼트를 받은 패시브 클로즈 호스트가 ACK 세그먼트를 보낸 후 대기하는 상태
        - FIN-WAIT-2: FIN-WAIT-1 상태에서 ACK 세그먼트를 받고 상대 호스트의 FIN 세그먼트를 기다리는 상태
        - LAST-ACK: CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 이에 대한 ACK 세그먼트를 기다리는 상태
        - TIME-WAIT: 액티브 클로즈 호스트가 FIN 세그먼트를 수신한 뒤, 이에 대한 ACK 세그먼트를 전송한 뒤 접어드는 상태
            - 패시브 클로즈 호스트는 마지막 ACK 세그먼트를 수신하면 CLOSED 상태로 전이
            - 액티브 클로즈 호스트는 일정 시간을 기다린 뒤 CLOSED 상태로 전이
- 명령어로 TCP의 상태 확인
    - `netstat`
### UDP
- UDP 데이터그램의 구조
    - UDP는 TCP와 달리 비연결형 통신을 수행하는 신뢰할 수 없는 프로토콜
    - 그래서 연결 수립 및 해제, 재전송을 통한 오류 제어, 혼잡 제어, 흐름 제어 등을 수행하지 않음
    - 상태를 유지하지도 않음: stateless 프로토콜
    - UDP는 TCP에 비해 적은 오버헤드로 패킷을 빠르게 처리
    - 주로 실시간 스트리밍 서비스, 인터넷 전화처럼 실시간성이 강조되는 상황에서 TCP보다 더 많이 쓰임
## TCP의 오류·흐름·혼잡 제어
### TCP의 오류·흐름·혼잡 제어
- TCP의 기능
    - 재전송을 기반으로 다양한 오류를 제어
    - 흐름 제어를 통해 처리할 수 있을 만큼의 데이터 송수신
    - 혼잡 제어를 통해 네트워크가 혼잡한 정도에 따라 전송량 조절
### 재전송 기반 오류 제어
- 오류 검출과 재전송
    - TCP 세그먼트의 체크섬 필드, 충분할까?
    - TCP가 신뢰성을 제대로 보장하려면?
        - 송신 호스트가 송신한 세그먼트에 문제가 발생했음을 인지할 수 있어야 함
        - 오류를 감지하게 되면 해당 세그먼트를 재전송할 수 있어야 함
    - 그렇다면 TCP는 언제 오류를 검출하고 재전송할까?
        - 중복된 ACK 세그먼트를 수신했을 때
        - 타임아웃이 발생했을 때
- 재전송 기법: ARQ(Automatic Repeat Request, 자동 재전송 요구)
    - 수신 호스트의 답변(ACK)와 타임아웃을 토대로 문제를 진단하고
    - 문제가 생긴 메세지를 재전송함으로써 신뢰성을 확보하는 방식
- ARQ의 대표적인 세 가지 방식
    - Stop-and-Wait ARQ
        - 제대로 전달했음을 확인하기 전까지는 새로운 메세지를 보내지 않는 방식
    - Go-Back-N ARQ
        - 파이프라이닝 기반 ARQ 일종
        - 여러 세그먼트 전송 중 오류가 발생하면 해당 세그먼트부터 전부 재전송
        - ACK 세그먼트는 누적 확인 응답
    - Selective Repeat ARQ
        - 선택적으로 재전송: 각각의 패킷들에 대해 ACK 세그먼트를 보내는 방식
        - ACK 세그먼트는 개별 확인 응답
        - 대부분의 호스트는 이 방식 사용
    - 참고: 빠른 재전송(fast retransmit)
        - 재전송 타이머가 만료되기 전이라도 세 번의 동일한 ACK 세그먼트를 받으면 곧바로 재전송

### 흐름 제어
- 파이프라이닝 기반
    - 한 번에 무한히 많이 데이터를 보내고 받을 수 없음
- 파이프라이닝 기반 Go-Back-N ARQ / Selective Repeat ARQ 가 정상 작동하려면
    - 수신 호스트가 한 번에 얼마나 받아 처리할 수 있는지 반드시 고려해야 함
    - 호스트가 한 번에 받아서 처리할 수 있는 세그먼트의 양에는 한계가 있기 때문
- TCP의 흐름 제어
    - 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 일정하게 유지하는 기능
- 슬라이딩 윈도우(sliding window): TCP 흐름 제어 기법
    - 윈도우(window): 송신 호스트가 파이프라이닝 할 수 있는 최대량
    - 즉, 윈도우의 크기만큼 확인 응답을 받지 않고도 한 번에 전송 가능하다는 의미
    - 확인 응답을 받을 때마다 윈도우가 점차 오른쪽으로 슬라이딩하듯이 움직여서 비롯됨
- 송신 측의 윈도우(송신 윈도우)도 있음
    - 수신 호스트는 TCP 헤더(윈도우 필드)를 통해 송신 호스트에게 자신이 받을 데이터의 양을 알려줌
    - 송신 윈도우: 헤더로 전달받은 수신 윈도우 토대로 연산

### 혼잡 제어
- 혼잡(congestion)
    - 많은 트래픽으로 인해 패킷의 처리 속도가 늦어지거나 유실될 우려가 있는 네트워크 상황
- TCP의 혼잡 제어(congestion control)
    - 송신 호스트가 혼잡한 정도에 맞춰 유동적으로 전송량을 조정하는 기능
    - 흐름 제어의 주체가 수신 호스트라면 혼잡 제어는 송신 호스트
    - 혼잡 윈도우(congestion window): 혼잡 없이 전송할 수 있을 법한 데이터양
    - 흐름 제어에서 수신 윈도우는 수신 호스트가 헤더로 알려줌
    - 혼잡 윈도우는 송신 호스트가 알아서 직접 계산해서 알아내야 함
- TCP의 혼잡 제어 알고리즘
    - 혼잡 제어를 수행하는 일련의 방법
    - 가장 기본적인 알고리즘인 AIMD (Additive Increase/Multiplicative Decrease)
        - '합으로 증가, 곱으로 감소'
        - 혼잡이 감지되지 않는다면: 혼잡 윈도우를 RTT(Round Trip Time)마다 1씩 선형적으로 증가
        - 혼잡이 감지되면: 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복
- RTT (Round Trip Time)
    - 메세지를 전송한 뒤 그에 대한 답변을 받는 데까지 걸리는 시간
    - `ping` 명령어 결과에서도 볼 수 있음
- 느린 시작(slow start) 알고리즘
    - 혼잡 윈도우를 1부터 시작해 문제 없이 수신된 ACK 세그먼트 하나당 1씩 증가시키는 방식
    - 혼잡 윈도우는 RTT마다 2배씩 지수적으로 증가: 초기 전송 속도 빠른 확보
    - 느린 시작 임계치(slow start threshold)
    - 혼잡 윈도우 값이 계속 증가하다가
        - 혼잡 윈도우 크기가 느린 시작 임계치 이상이 되면
            - 느린 시작 종료, 혼잡 회피 수행
        - 타임아웃이 발생하면
            - 혼잡 윈도우 값을 1로, 느린 시작 임계치를 혼잡이 감지됐을 때의 절반으로 줄이고 느린 시작 재개
        - 세 번의 중복된 ACK 세그먼트를 수신하면
            - (빠른 재전송 후)빠른 회복 수행
- 혼잡 회피 알고리즘
    - RTT마다 혼잡 윈도우를 1MSS 씩 증가시키는 알고리즘
    - 혼잡 윈도우 크기 선형적으로 증가
    - 느린 시작 임계치를 넘으면 혼잡 여지가 있으니 천천히 혼잡 윈도우 증가하기
- 빠른 회복 알고리즘
    - 세 번의 중복 세그먼트 수신 vs 타임아웃 뭐가 더 심각한 문제일까? -> 보통 타임아웃 
    - 세 번의 중복 세그먼트 수신 -> 이 정도는 느린 시작 건너뜀
    - 빠른 전송률 회복을 위해 느린 시작은 건너뛰고 혼잡 회피를 수행하는 알고리즘
    - 단, 빠른 회복 도중이라도 타임아웃이 일어나면 다시 느린 시작을 수행