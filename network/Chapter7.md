# 네트워크 심화
## 안정성을 위한 기술
### 안정성을 수치로 표현하는 가용성
- 가용성(availability)
    - 컴퓨터 시스템이 특정 기능을 실제로 수행할 수 있는 시간의 비율
    - 전체 사용 시간 중에서 정상적인 사용 시간
        - 업타임(uptime): 정상적인 사용 시간
        - 다운타임(downtime): 정상적인 사용이 불가능한 시간
    - 고가용성(HA)
- 일반적으로 '안정적'인 시스템은 가용성 99.999%(파이브 나인스) 이상을 목표
### 그렇다면 안정성은 어떻게 높일 수 있을까?
- 다운타임을 낮추면 됨
    - 서비스는 왜 다운될까?
        - 과도한 트래픽
        - 예기치 못한 소프트웨어상의 오류
        - 하드웨어 문제
    - 결함 감내(fault tolerance)
        - 문제가 발생하더라도 기능할 수 있는 능력
### 이중화
- 결함을 감내하여 가용성을 높이기 위한 가장 기본적이고 대표적인 방법
    - '백업을 마련하는 방법'
    - 무엇을 이중화해야 할까?
    - '문제가 발생할 경우 시스템 전체가 중단될 수 있는 대상': SPoF (Single Point of Failure)
        - 서버 컴퓨터, 네트워크 인터페이스, 스위치 등 물리적 장비
        - 데이터베이스, 웹 서버 프로그램 등
- 구성 방법
    - 액티브/스탠바이(active-standby)
        - 한 시스템은 가동하고, 다른 시스템은 백업 용도로 대기 상태(스탠바이)
    - 액티브/액티브(active-active)
        - 두 시스템 모두를 가동 상태
- 이중화의 확장, 다중화
    - 무언가를 여러 개 두는 기술
- 이중화/다중화의 사례, 티밍(teaming)과 본딩(bonding)
    - 여러 네트워크 인터페이스(NIC)를 이중화/다중화하여 더 뛰어나고 안정적인 성능의 하나의 인터페이스처럼 보이게 하는 기술
### 로드 밸런싱
- 로드 밸런싱(load balancing), 트래픽의 고른 분배를 위한 기술
    - 로드 밸런서(load balancer)에 의해 수행
        - 전용 네트워크 장비(L4 스위치, L7 스위치)로 수행
            - L4 스위치는 IP 주소와 포트 번호와 같은 전송 계층까지의 정보를 바탕으로 로드 밸런싱
            - L7 스위치는 URI, HTTP 일부, 쿠키 등 응용 계층의 정보까지 활용하여 로드 밸런싱
        - 로드 밸런싱 소프트웨어를 설치하면 일반 호스트도 로드 밸런서로 사용 가능
            - HAProxy, Envoy 등
            - Nginx에도 로드 밸런싱 기능이 내포
- 로드 밸런서의 위치
    - 일반적으로 이중화/다중화된 서버와 클라이언트 사이에 위치
    - 클라이언트들은 로드 밸런서에 요청을 보내고, 로드 밸런서는 해당  요청을 각 서버에 균등하게 분배
- 서버의 상태를 검사하는 헬스 체크
    - 헬스 체크(health check)
        - 서버들의 건강 상태를 주기적으로 모니터링하고 체크
        - 주로 로드 밸런서에 의해 이루어짐
        - HTTP, ICMP 등 다양한 프로토콜을 활용
    - 서버 간 하트비트(heartbeat)라는 메시지를 주기적으로 주고받는 방법도 있음
- 로드 밸런싱 알고리즘
    - 라운드 로빈 알고리즘(round robin algorithm)
        - 단순히 서버를 돌아가며 부하를 전달
    - 최소 연결 알고리즘(least connection algorithm)
        - 연결이 적은 서버부터 우선적으로 부하를 전달
    - 기타
        - 무작위
        - 해시(hash) 자료구조를 이용하는 알고리즘
        - 응답 시간이 가장 짧은 서버를 선택하는 알고리즘
- 가중치가 부여된 알고리즘
    - 가중치 라운드 로빈 알고리즘(weighted round robin algorithm)
    - 가중치 최소 연결 알고리즘(weighted least connection algorithm)
    - 서버 간 성능이 다른 경우 주로 가중치가 적용된 알고리즘이 유리
### 중간 서버와 다중화된 오리진 서버
- 클라이언트와 일반적으로 서버 사이에는 수많은 서버가 존재할 수 있음
- 실제로는 서버가 다중화된 경우가 많음
- 기존에 단순히 '서버'라 지칭한 대상
    - 클라이언트가 최종적으로 메시지를 주고받는 대상
    - 자원을 생성하고 클라이언트에게 권한있는 응답을 보낼 수 있는 HTTP 서버
    - = 오리진 서버
    - 인바운드(inbound) 메시지: 오리진 서버를 향하는 메시지
    - 아웃바운드(outbound) 메시지: 클라이언트를 향하는 메시지
### 대표적인 HTTP 중간 서버
- 프록시(proxy): 포워드 프록시
    - 클라이언트가 선택한 메시지 전달 대리자
    - 프록시를 언제 어떻게 사용할지는 클라이언트가 선택
    - 오리진 서버보다 클라이언트와 더 가까이 위치
    - 캐싱, 클라이언트 암호화, 접근 제한 등
- 게이트웨이(gateway): 리버스 프록시
    - 일반적 의미: 네트워크 간의 통신을 가능하게 하는 입구 역할을 하는 HW/SW
    - 'HTTP'중간 서버' 맥락에서의 의미
        - 아웃바운드 연결에 대해 오리진 서버 역할을 수행하는 중개자
        - 수신된 요청 메시지를 다른 인바운드 서버(들)에 전달하는 중개자
    - 클라이언트가 보기에 오리진 서버와 같이 보임
    - 클라이언트 요청을 오리진 서버에 전달하기 위해 오리진 서버(들)에 더 가까이 위치
    - 캐싱, 로드 밸런싱

## 안전성을 위한 기술
### 안전한 네트워크를 위한 기술
- 암호화 & 복호화
    - 암호화: 원문 데이터를 알아보기 어려운 형태로 변경하는 과정
    - 복호화: 암호화된 데이터를 원문 데이터로 되돌리는 과정
    - 안전한 데이터 송수신뿐만 아니라 인증서 기반의 검증도 가능하게 함
### 대칭 키 암호화 방식과 공개 키 암호화 방식
- 암호화와 복호화의 핵심은 키(key)
    - 키에 수학적 연산(=암호화 알고리즘)을 거치면 암호문 생성
- 키를 기반으로 암호화/복호화하는 두 가지 방식
    - 대칭 키 암호화
    - 비대칭 키 암호화(=공개 키 암호화)
- 대칭 키 암호화(symmetric-key cryptography)
    - 암호화와 복호화에 동일한 키를 사용하는 방식
    - 동일한 키를 사용하므로 키가 유출되면 큰 문제 발생
    - 따라서 당연하게도 키를 안전하게 상대방에 전달해야 함: 이게 어려움
- 비대칭 키 암호화(asymmetric-key cryptography)
    - 암호화에 사용되는 키와 복호화에 사용되는 키가 다름
    - 한 쌍의 키(공개 키, 개인 키)를 사용: 한 키로 암호화, 다른 키로 복호화
    - 공개 키(public key)를 알아도 개인 키(private key) 유추 불가능. 역도 마찬가지
- 세션 키 (session key)
    - 대칭 키를 공개 키로 암호화하고 개인 키로 암호화된 대칭 키 복호화한다면?
    - 안전한 대칭 키 공유 가능
    - 빠른 대칭키 기반 암호화/복호화 가능
    - 이렇게 사용되는 대칭 키 = 세션 키(session key)

### 인증서와 디지털 서명
- 인증서(certificate)
    - 무엇인가를 증명하기 위한 문서
    - 네트워크(인터넷)에서의 인증서 = 일반적으로 '공개 키 인증서(public key certificate)'
- 공개 키 인증서(public key certificate)
    - 공개 키와 공개 키의 유효성을 입증하기 위한 전자 문서
- 인증 기관(CA, Certification Authority)
    - 인증서의 발급, 검증, 저장과 같은 역할을 수행할 수 있는 공인 기관
    - 대표적인 인증 기관
        -IdenTrust, DigiCert, GlobalSign 등
- 서명 값(signature)
    - 인증 기관(CA)의 인증 정보
    - 이 공개 키 인증서는 진짜라는걸 보증
    - 클라이언트는 CA가 발급한 인증서의 서명 값을 바탕으로 인증서를 검증
- 서명 값 생성의 원리
    1. 인증서 내용에 대한 해시 값을
    2. CA의 개인 키로 암호화하는 방식으로 생성
    - CA는 이렇게 얻어낸 정보를 서명 값으로 삼아 클라이언트에게 인증서와 함께 전송
- 해시 값
    - 해시 함수를 적용시킨 결과값
        - 해시 함수란
            - 임의의 길이의 데이터를 고정된 길이의 데이터로 변환하는 함수
            - MD5, SHA-1, SHA-2 등
    - 데이터 변조 여부 검사에 사용
- 인증서 검증 과정
    1. 서명 값과 인증서 분리
    2. 서명 값을 CA의 공개 키로 복호화하여 '인증서 내용에 대한 해시 값'을 얻음
    3. 인증서 데이터에 대한 해시 값을 직접 계산
    4. 이를 복호화한 값과 비교
    - 디지털 서명(digital signature)
        - 개인 키로 암호화된 메시지를 공개 키로 복호화함으로써 신원을 증명하는 절차

### HTTPS: SSL과 TLS
- SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)
    - 인증과 암호화를 수행하는 프로토콜
    - TLS는 SSL을 계승한 프로토콜: 작동 과정은 큰 틀에서 보면 유사함
    - 초기 SSL 2.0과 SSL 3.0을 거쳐 TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3이 순차적으로 출시
- HTTPS(HTTP over TLS)
    - SSL/TLS를 사용하는 대표적인 프로토콜
    - HTTPS는 HTTP 메시지의 안정한 송수신을 위해 개발된 프로토콜
- HTTPS 메시지의 송수신 단계
    1. TCP 쓰리 웨이 핸드셰이크
    2. TLS 핸드셰이크
    3. 암호화된 메시지 송수신
- TLS 핸드셰이크에서의 키 교환
    - 클라이언트의 ClientHello 메시지
        - 암호화된 통신을 위해 서로 맞춰 봐야 할 정보들을 제시하는 메시지
        - 지원 TLS 버전, 사용 가능한 암호화 알고리즘과 해시 함수, 키 생성에 필요한 난수 등이 포함
    - 서버의 ServerHello 메시지
        - ServerHello 메시지는 제시된 정보들을 선택하는 메시지
        - 선택된 TLS 버전, 사용 가능한 암호화 알고리즘과 해시 함수, 키 생성에 필요한 난수 등이 포함
    - ClientHello, ServerHello를 주고받으면 암호화 통신을 위해 사전 협의해야 할 정보들이 결정됨
        - 서버와 클라이언트는 암호화에 사용할 키를 생성
    - 암호 스위트(cipher suite)
        - '사용 가능한 암호화 방식과 해시 함수'를 담은 정보
- TLS 핸드셰이크에서의 인증서 및 인증서 검증
    - 서버는 Certificate 메시지와 CertificateVerify 메시지 전송
        - 각각 인증서와 검증을 위한 디지털 서명
    - 클라이언트는 이 메시지를 토대로 서버의 공개 키 검증
- TLS 핸드셰이크 마무리, 암호화 통신 수행
    - 서버와 클라이언트는 TLS 핸드셰이크의 마지막을 의미하는 Finished 메시지를 주고 받음
    - 이제 주고받은 키를 바탕으로 암호화 데이터(Application Data) 주고받음
