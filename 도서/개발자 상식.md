# 목차
- 1장
    - 애자일 방법론
- 2장
    - 목적에 따른 언어
    - 인터프리터 언어와 컴파일 언어
    - 정적타입 언어와 동적타입 언어
- 3장
    - 오픈소스 소프트웨어 라이선스
    - 라이브러리와 프레임워크 차이점
- 4장
    - 좋은 코드(클린 코드)
    - 리팩토링
    - 코딩 컨벤션
- 5장
    - 프로세스
- 6장
    - 운영체제 
    - 네트워크
- 7장
- 8장
- 9장
- 10장
- 11장   
# 1장
## 애자일 방법론
Agile : 날렵한, 민첩한, 재빠른, 기민한   
비즈니스 사이클이 짧아짐에 따라 등장한 Agile한 방법   
4가지 가치   
1. 공정과 도구보다 **개인과 상호 작용**을 가치있게 여긴다
2. 포괄적인 문서보다 **작동하는 소프트웨어**를 가치있게 여긴다
3. 계약 협상보다 **고객과 협력**을 가치있게 여긴다
4. 계획을 따르기보다 **변화에 대응**하는 것을 가치 있게 여긴다   

애자일 방법론의 종류   
|종류|내용|
|:----:|:-----|
|XP, Extreme Programming|고객과 빠르게 소통하며 개발하는 방법|
|Pair Programming|두 사람이 짝이 되어 한 사람은 코딩, 다른 사람은 검사를 하는 방법|
|TDD, Test Driven Development|테스트 케이스를 먼저 작성하고 이를 통과하는 코드를 개발하는 방법|
|Scrum|sprint마다 부분적인 결과물이 만들어지는 반복적이고 점진적인 개발 방법|
# 2장
## 목적에 따른 언어 
- 프론트엔드 : HTML, CSS, 자바스크립트, 타입스크립트 등
- 백엔드 : 자바스크립트(Node.js), 자바(스프링), C++, 파이썬(장고), Go, 루비(레일즈), PHP 등
- 모바일 : 자바, 코틀린, 오브젝티브-C, 스위프트, 다트(플러터), 리액트 네이티브 등
- 데스크톱 프로그래밍, 임베디드 : C, C++, C#, 어셈블리어, 다트(플러터), 자바스크립트(일렉트론) 등
- 게임 프로그래밍 : C#(유니티), C, C++
- AI, ML : 파이썬, R
## 인터프리터 언어와 컴파일 언어
- 인터프리터 언어 : 소스 코드를 한 줄씩 읽고 해석한 뒤 실행(런타임 사용)
- 컴파일 언어 : 소스 코드 전체를 기계어로 변환한 뒤 실행(컴파일 타임 사용, 빌드를 통해 실행가능한 파일로 변환)
## 정적타입 언어와 동적타입 언어
- 정적타입 언어 : **컴파일** 시 변수의 타입이 결정되는 언어 (C, C++, 자바 등)
- 동적타입 언어 : **런타임** 시 변수의 타입이 결정되는 언어 (파이썬, 루비, 자바스크립트 등)
# 3장
## 오픈소스 소프트웨어 라이선스
### MIT
무료로 소스코드를 배포, 수정이 가능하며 2차 저작물을 공개할 의무가 없는 라이선스
### 아파치
MIT와 거의 동일하나 아파치 재단에서 개발한 소프트웨어임을 명확히 밝혀야 함
### GPL
제약 조건이 높은 라이선스로 수정한 소스코드 또는 GPL 라이선스를 가진 소스코드를 활용한 소프트웨어를 모두 GPL 라이선스로 공개해야 함   
### 저작권 표기 방법
소스코드의 주석, 또는 README.md 파일이나 LICENSE.md 파일에 표기   
배포 소프트웨어의 경우 Copyright 또는 오픈소스 라이선스 메뉴에 저작권 내용 표기
## 라이브러리와 프레임워크 차이점
- 라이브러리 : 부품이 되는 소프트웨어의 집합, 개발자가 호출해서 사용
- 프레임워크 : 소프트웨어의 형식을 제공하는 것, 개발자의 코드가 호출됨
# 4장
## 좋은 코드(클린 코드)
논리가 간단하고 가독성이 좋은 코드   
주요 원칙
 1. 컨벤션을 준수
 2. 단순함 추구
 3. Boy Scout Rule : 참조되거나 수정되는 코드는 원래보다 깔끔해야 한다
 4. 근본적인 원인 해결
 5. 하나의 파일은 하나의 언어로 작성
 ## 리팩토링
 이미 작성한 소스코드에서 구현된 기능, 로직은 변경하지 않고 코드의 가독성과 유지보수성을 높이기 위해 내부 구조만 변경하는 것   
 ### 리팩토링이 필요한 경우 :
 1. 유사한 내용이 세 번 이상 반복될 때
 2. 새로운 기능을 추가할 때
 3. 코드 리뷰를 할 때
 4. **레거시 코드**가 존재할 때
 
 *레거시 코드 : 누군가 떠나면서 남겨 논 코드   
 ### 리팩토링 방법
 - Extract Method : 함수 분리
    - 너무 긴 함수 분리
 - Move Class : 클래스 이동
    - 다른 클래스에서 더 많이 사용하는 함수면 그 클래스로 이동
 - Rename : 이름 변경
    - 함수, 변수, 클래스, 객체 등의 이름을 혼동과 오해가 없게 변경
 - Consolidatet conditional expression : 중복 조건식 통합
    - 중복되는 분기문을 클래스로 만들거나 동적으로 변경
 - Remove Control Flag : 제어 플래그 제거
    - 제어 플래그보다는 return 사용
 
## 코딩 컨벤션
### 네이밍 규칙
#### Pascal Casing
- 클래스, 열거형, 이벤트 등의 이름을 만들 때 대문자로 시작
- 복합어일 경우 중간에 시작하는 새로운 단어는 대문자로 작성   
ex) UserClass, MainFrame, SubFrame
#### Camel Casing
- 함수의 매개변수 이름에 적용되는 첫 번째 문자는 소문자로 시작
- 복합어일 경우 파스칼 케이싱과 동일
- 주로 자바에서 많이 사용   
ex) userClass, mainFrame, subFrame
#### GNU Naming Convention, Snake Case
- 리눅스 프로젝트들은 GNU라고 하는 형태의 명명법을 주로 사용
- Snake Case와 동일하며 C에서 많이 사용
- 모두 소문자를 사용하고, 복합어 사이는'_'로 연결   
ex) user_class, main_frame, sub_frame
#### Constant
- 모든 문자를 대문자로 사용하고 복합어 사이는 '_'로 연결
### 암묵적인 네이밍 규칙
1. 변수와 클래스에는 동사 사용을 지양
2. 함수에는 코드의 기능을 알 수 있는 동사 사용
3. 변수명에는 관사 및 전치사 사용은 지양, 복수 사용은 지향
4. 통상적으로 사용되는 변수명 및 규칙 사용   
ex) tmp, obj, worker, flag, idx, info, freq, token, num 
5. 상수는 모두 대문자 사용
6. 변수가 길어질 경우 축약   
ex) total_distance -> total_dist, number -> num
#### 기타 암묵적인 스타일 규칙
1. 들여쓰기 습관화
2. 연산자 사이에 공백
3. 괄호 사이에 불필요한 공백은 없게 한다
4. 주석은 되도록 짧게 한 줄로 축약
5. 하단 코드를 설명하기 위해서는 독립된 줄에 주석 작성,   
 주석 앞의 코드를 설명하기 위해서는 줄 끝에 주석 작성
# 5장
## 프로세스
프로그램 실행 시 제일 먼저 프로그램 코드가 메모리에 로드되는데, 이렇게 메모리에 적재된 프로그램이 바로 프로세스   
운영체제에 의해 메모리의 일부 공간을 할당 받아 생성됨
# 6장
