# 목차
- [[1장] 디자인 패턴 소개와 전략 패턴](#1장-디자인-패턴의-세계로-떠나기)
- [[2장] 옵저버 패턴](#2장-객체들에게-연락-돌리기)
- [[3장] 데코레이터 패턴](#3장-객체-꾸미기)
- [[4장] 팩토리 패턴](#4장-객체지향-빵-굽기)
- [[5장] 싱글턴 패턴](#5장-하나뿐인-특별한-객체-만들기)
- [[6장] 커맨드 패턴](#6장-호출-캡슐화하기)
- [[7장] 어댑터 패턴과 퍼사드 패턴](#7장-적응시키기)
# [1장] 디자인 패턴의 세계로 떠나기
- 오리 시뮬레이션 게임, SimUduck
    - 문제: Duck의 서브클래스에서 몇몇 서브클래스만 fly()를 넣고 싶음
    - 문제가 있는 해결방법
        - 상속
            - Duck에 fly()를 추가
            - 원하지 않는 서브클래스는 fly()를 오버라이드해야함
        - Flyable 인터페이스
            - 코드 중복
    - **애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다, 구현보다는 인터페이스에 맞춰서 프로그래밍한다**
    - **구현보다는 인터페이스에 맞춰서 프로그래밍한다**
        - Duck 클래스를 두고, fly()와 quack()에 대한 2개의 클래스 집합을 새로 만듦
        - FlyBehavior과 QuackBehavior 인터페이스를 사용함
        - 이 두 인터페이스를 Duck의 인스턴스 변수로 추가
        - flyBehavior.fly(), quackBehavior.quack() 처럼 사용
        - 동적으로 setter로 인터페이스의 구현체를 바꾸면 동작도 변경
    - 클래스  사이의 관계
        - A는 B이다: 상속
        - A에는 B가 있다: 구성(composition)
        - A가 B를 구현한다: 인터페이스
- **전략 패턴(Strategy Pattern)**
    - 알고리즘을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 함
    - 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있음

# [2장] 객체들에게 연락 돌리기
- 기상 모니터링 애플리케이션
    - WeatherData 객체를 제공받아, 디스플레이를 만들어야 하는 상황
    - 객체에는 getTemperature, gethumidity, getPressure 메소드와
    - 관측값이 갱신될 때마다 호출되는 measurementsChanged 메소드가 있어서 이걸 구현해야 함
    - 문제가 있는 해결방법
        - display1.update(), display2.update() 등 구체적인 구현
            - 실행 중에 디스플레이를 더하거나 뺄 수 없음
    - 기상 스테이션 구현(push)
        - 주제는 registerObserver, removeObserver, notifyObservers 메소드가 있음
        - 옵저버는 update 메소드가 있음
        - WeatherData가 주제를 구현함
            - notifyObservers에서 `observer.update(temperature, humidity, pressure)`
        - Display가 옵저버를 구현함
        - 이 방식은 주제가 옵저버에게 상태를 알리는 push 방식
            - 옵저버가 원하지 않는 정보도 다 주는 건 단점
    - 기상 스테이션 구현(pull)
        - notifyObservers에서 `observer.update()`
        - `update`에서 getter로 temparature, humidity, pressure중 알아서 가져옴
- **옵저버 패턴(Observer Pattern)**
    - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고
    - 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의함
- 느슨한 결합(Loose Coupling)
    - 객체들이 상호작용 할 수는 있으나, 서로를 잘 모르는 관계
    - 인터페이스를 활용한 옵저버 패턴이 예시

# [3장] 객체 꾸미기
- 초대형 커피 전문점, 스타버즈
    - 각 음료의 설명과 가격을 알려주는 주문 시스템을 만들고 싶음
    - 문제가 있는 해결방법
        - description, getDescription()과 cost()가 있는 Beverage 추상 클래스를 만들고 각각의 음료를 서브클래스로 만듦
            - 토핑 추가 등도 모두 각각 서브클래스로 만들어야 해서 갯수가 매우 많아짐
        - description과 milk, mocha 등의 첨가물을 인스턴스 변수로 추가하고, 서브클래스의 cost()는 Beverage의 cost() + Alpha인 형식
            - 첨가물의 가격이 바뀔 때마다 코드를 수정해야 함
            - 첨가물과 관련 없는 서브클래스가 있을 수 있음 (Tea 등)
            - 더플 mocha 등은 hasMocha로 검사해서 더하기 어려움
    - 데코레이터 패턴으로 구현
        - DarkRoast 객체를 가져온다
        - Mocha 객체로 장식
        - Whip 객체로 장식
        - cost()메소드 호출
            - 첨가물의 가격을 계산하는 일은 해당 객체에 위임
            - 즉 Whip cost() -> Mocha cost() -> DarkRoast cost() 순으로 호출됨
        - Mocha(beverage) 처럼 생성하고, cost는 beverage.cost() + Alpha
- OCP(Open-Closed Principle)
    - **클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다**
- **데코레이터 패턴(Decorator Pattern)**
    - 객체에 추가 요소를 동적으로 더할 수 있음
    - 서브클래스를 만들 때보다 훨씬 유연하게 기능 확장 가능

# [4장] 객체지향 빵 굽기
- 최첨단 피자 코드 만들기
    - 피자 가게를 운영하는 코드
    - **간단한 팩토리(Simple Factory)**
        - 디자인보다는 자주 쓰이는 관용구
        - orderPizza()에서 Pizza를 생성하는 부분과 나머지 변하지 않는 부분을 분리
            - PizzaStore 안에 SimplePizzaFactory가 있는 구조
            - `pizza = factory.createPizza(type)` 후 나머지 로직 수행
    - 다양한 팩토리 만들기(지점마다 피자의 스타일이 다른 경우)
        - PizzaStore를 추상 클래스로 만들고 팩토리 객체 대신 추상 메소드 createPizza 로 변경
        - NYStylePizzaStore, ChicagoStylePizzaStore 등 지점을 구상 클래스로
        - createPizza에서 각각 NYStyleCheesePizza, ChicagoStyleCheesePizza 등을 만들 수 있음
- **팩토리 메소드 패턴**
    - 객체를 생성할 때 필요한 인터페이스를 만듦
    - 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정
    - 팩토리 메소드는 객체 생성을 서브클래스에 캡슐화할 수 있음
    - Creator 클래스와 Product 클래스로 나뉨
- **의존성 뒤집기 원칙(Dependency Inversion Principle)**
    - 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만드는 원칙
    - 고수준 구성 요소(PizzaStore)가 저수준 구성 요소(피자 클래스)에 의존하면 안됨
- **추상 팩토리 패턴**
    - 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스 제공
    - 구상 클래스는 서브클래스로 생성

# [5장] 하나뿐인 특별한 객체 만들기
- **싱글턴 패턴**
    - 클래스 인스턴스를 하나만 만들고 전역 접근을 제공
- 구현 방법
    - 생성자를 private으로 하고 getInstance 메소드가 있는 싱글턴 클래스
        - 방법 1
            - getInstance에서는 uniqueInstance가 이미 생성됐는지 null 체크
            - 멀티스레딩 문제를 해결하기 위해서 synchronized 키워드 추가
        - 방법 2
            - `private static Singleton uniqueInstance = new Singleton();`
            - 이 방법을 쓰면 JVM이 하나뿐인 인스턴스를 생성해줌
        - 방법 3
            - DCL(Double-Checked Locking) 사용
    - Java enum

# [6장] 호출 캡슐화하기
- 리모컨 API 만들기
    - 8개의 버튼에 각각 on / off 가 있어서 기능을 만들어야함
    - 리모컨이 인보커 객체이고, 각 버튼이 커맨드 객체이고 누르는게 execute()
    - 하나의 버튼을 누르면 여러 커맨드가 실행되게 매크로 커맨드를 만들 수도 있음
- **커맨드 패턴**
    - 요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화
    - 커맨드 객체
        - execute() 메소드를 가지고 있음
        - 리시버 객체가 있어서 execute()안에서는 receiver.action() 등을 함
    - 클라이언트 객체
        - 커맨드 객체를 생성하고, 인보커 객체의 setCommand() 메소드를 호출해 커맨드 객체를 전달함
    - 인보커 객체    
        - 커맨드 객체의 execute()를 호출함

# [7장] 적응시키기
- **어댑터 패턴**
    - 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환해줌