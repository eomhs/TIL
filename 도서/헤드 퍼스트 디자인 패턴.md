# 목차
- [[1장] 디자인 패턴 소개와 전략 패턴](#[1장]-디자인-패턴의-세계로-떠나기)
- [[2장] 옵저버 패턴](#[2장]-객체들에게-연락-돌리기)
# [1장] 디자인 패턴의 세계로 떠나기
- 오리 시뮬레이션 게임, SimUduck
    - 문제: Duck의 서브클래스에서 몇몇 서브클래스만 fly()를 넣고 싶음
    - 문제가 있는 해결방법
        - 상속
            - Duck에 fly()를 추가
            - 원하지 않는 서브클래스는 fly()를 오버라이드해야함
        - Flyable 인터페이스
            - 코드 중복
    - **애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다, 구현보다는 인터페이스에 맞춰서 프로그래밍한다**
    - **구현보다는 인터페이스에 맞춰서 프로그래밍한다**
        - Duck 클래스를 두고, fly()와 quack()에 대한 2개의 클래스 집합을 새로 만듦
        - FlyBehavior과 QuackBehavior 인터페이스를 사용함
        - 이 두 인터페이스를 Duck의 인스턴스 변수로 추가
        - flyBehavior.fly(), quackBehavior.quack() 처럼 사용
        - 동적으로 setter로 인터페이스의 구현체를 바꾸면 동작도 변경
    - 클래스  사이의 관계
        - A는 B이다: 상속
        - A에는 B가 있다: 구성(composition)
        - A가 B를 구현한다: 인터페이스
- **전략 패턴(Strategy Pattern)**
    - 알고리즘을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 함
    - 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있음

# [2장] 객체들에게 연락 돌리기
- 기상 모니터링 애플리케이션
    - WeatherData 객체를 제공받아, 디스플레이를 만들어야 하는 상황
    - 객체에는 getTemperature, gethumidity, getPressure 메소드와
    - 관측값이 갱신될 때마다 호출되는 measurementsChanged 메소드가 있어서 이걸 구현해야 함
    - 문제가 있는 해결방법
        - display1.update(), display2.update() 등 구체적인 구현
            - 실행 중에 디스플레이를 더하거나 뺄 수 없음
- **옵저버 패턴(Observer Pattern)**
    - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고
    - 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의함
- 느슨한 결합(Loose Coupling)
    - 객체들이 상호작용 할 수는 있으나, 서로를 잘 모르는 관계
    - 인터페이스를 활용한 옵저버 패턴이 예시