# 목차
- [[1장] 디자인 패턴 소개와 전략 패턴](#1장-디자인-패턴의-세계로-떠나기)
- [[2장] 옵저버 패턴](#2장-객체들에게-연락-돌리기)
- [[3장] 데코레이터 패턴](#3장-객체-꾸미기)
# [1장] 디자인 패턴의 세계로 떠나기
- 오리 시뮬레이션 게임, SimUduck
    - 문제: Duck의 서브클래스에서 몇몇 서브클래스만 fly()를 넣고 싶음
    - 문제가 있는 해결방법
        - 상속
            - Duck에 fly()를 추가
            - 원하지 않는 서브클래스는 fly()를 오버라이드해야함
        - Flyable 인터페이스
            - 코드 중복
    - **애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다, 구현보다는 인터페이스에 맞춰서 프로그래밍한다**
    - **구현보다는 인터페이스에 맞춰서 프로그래밍한다**
        - Duck 클래스를 두고, fly()와 quack()에 대한 2개의 클래스 집합을 새로 만듦
        - FlyBehavior과 QuackBehavior 인터페이스를 사용함
        - 이 두 인터페이스를 Duck의 인스턴스 변수로 추가
        - flyBehavior.fly(), quackBehavior.quack() 처럼 사용
        - 동적으로 setter로 인터페이스의 구현체를 바꾸면 동작도 변경
    - 클래스  사이의 관계
        - A는 B이다: 상속
        - A에는 B가 있다: 구성(composition)
        - A가 B를 구현한다: 인터페이스
- **전략 패턴(Strategy Pattern)**
    - 알고리즘을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 함
    - 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있음

# [2장] 객체들에게 연락 돌리기
- 기상 모니터링 애플리케이션
    - WeatherData 객체를 제공받아, 디스플레이를 만들어야 하는 상황
    - 객체에는 getTemperature, gethumidity, getPressure 메소드와
    - 관측값이 갱신될 때마다 호출되는 measurementsChanged 메소드가 있어서 이걸 구현해야 함
    - 문제가 있는 해결방법
        - display1.update(), display2.update() 등 구체적인 구현
            - 실행 중에 디스플레이를 더하거나 뺄 수 없음
    - 기상 스테이션 구현(push)
        - 주제는 registerObserver, removeObserver, notifyObservers 메소드가 있음
        - 옵저버는 update 메소드가 있음
        - WeatherData가 주제를 구현함
            - notifyObservers에서 `observer.update(temperature, humidity, pressure)`
        - Display가 옵저버를 구현함
        - 이 방식은 주제가 옵저버에게 상태를 알리는 push 방식
            - 옵저버가 원하지 않는 정보도 다 주는 건 단점
    - 기상 스테이션 구현(pull)
        - notifyObservers에서 `observer.update()`
        - `update`에서 getter로 temparature, humidity, pressure중 알아서 가져옴
- **옵저버 패턴(Observer Pattern)**
    - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고
    - 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의함
- 느슨한 결합(Loose Coupling)
    - 객체들이 상호작용 할 수는 있으나, 서로를 잘 모르는 관계
    - 인터페이스를 활용한 옵저버 패턴이 예시

# [3장] 객체 꾸미기
- 초대형 커피 전문점, 스타버즈
    - 각 음료의 설명과 가격을 알려주는 주문 시스템을 만들고 싶음
    - 문제가 있는 해결방법
        - description, getDescription()과 cost()가 있는 Beverage 추상 클래스를 만들고 각각의 음료를 서브클래스로 만듦
            - 토핑 추가 등도 모두 각각 서브클래스로 만들어야 해서 갯수가 매우 많아짐
        - description과 milk, mocha 등의 첨가물을 인스턴스 변수로 추가하고, 서브클래스의 cost()는 Beverage의 cost() + Alpha인 형식
            - 첨가물의 가격이 바뀔 때마다 코드를 수정해야 함
            - 첨가물과 관련 없는 서브클래스가 있을 수 있음 (Tea 등)
            - 더플 mocha 등은 hasMocha로 검사해서 더하기 어려움
    - 데코레이터 패턴으로 구현
        - DarkRoast 객체를 가져온다
        - Mocha 객체로 장식
        - Whip 객체로 장식
        - cost()메소드 호출
            - 첨가물의 가격을 계산하는 일은 해당 객체에 위임
            - 즉 Whip cost() -> Mocha cost() -> DarkRoast cost() 순으로 호출됨
        - Mocha(beverage) 처럼 생성하고, cost는 beverage.cost() + Alpha
- OCP(Open-Closed Principle)
    - **클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다**
- **데코레이터 패턴(Decorator Pattern)**
    - 객체에 추가 요소를 동적으로 더할 수 있음
    - 서브클래스를 만들 때보다 훨씬 유연하게 기능 확장 가능